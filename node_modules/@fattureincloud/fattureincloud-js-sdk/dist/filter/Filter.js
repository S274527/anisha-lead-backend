"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _Condition = _interopRequireDefault(require("./Condition"));
var _Conjunction = _interopRequireDefault(require("./Conjunction"));
var _Disjunction = _interopRequireDefault(require("./Disjunction"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : String(i); }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * The Filter filter module.
 * @module filter/Filter
 */
var Filter = exports["default"] = /*#__PURE__*/function () {
  /**
     * Constructs a new <code>Filter</code>.
     * @param {filter/Expression} expression The expression.
     */
  function Filter() {
    var expression = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    _classCallCheck(this, Filter);
    /**
       * The expression.
       * @member {filter/Expression} expression
       */
    _defineProperty(this, "expression", null);
    this.expression = expression;
  }

  /**
     * Initializes a new instance of the Filter class with a Condition.
     * @param {String} field The field to compare.
     * @param {filter/Operator} operator The operator to use.
     * @param {String|Number|Boolean} value The value to compare.
     */
  _createClass(Filter, [{
    key: "where",
    value: function where(field, operator, value) {
      this.expression = new _Condition["default"](field, operator, value);
      return this;
    }

    /**
       * Initializes a new instance of the Filter class with an Expression.
       * @param {filter/Expression} expression The expression.
       */
  }, {
    key: "whereExpression",
    value: function whereExpression(expression) {
      this.expression = expression;
      return this;
    }

    /**
       * Adds an AND condition to the filter.
       * @param {String} field The field to compare.
       * @param {filter/Operator} operator The operator to use.
       * @param {String|Number|Boolean} value The value to compare.
       */
  }, {
    key: "and",
    value: function and(field, operator, value) {
      if (this.expression == null) {
        throw new Error('Cannot create a conjunction with an empty expression.');
      }
      var left = this.expression;
      var right = new _Condition["default"](field, operator, value);
      this.expression = new _Conjunction["default"](left, right);
      return this;
    }

    /**
       * Adds an AND expression to the filter.
       * @param {filter/Expression} expression The expression.
       */
  }, {
    key: "andExpression",
    value: function andExpression(expression) {
      if (this.expression == null || expression == null || expression === undefined) {
        throw new Error('Cannot create a conjunction with an empty expression.');
      }
      var left = this.expression;
      var right = expression;
      this.expression = new _Conjunction["default"](left, right);
      return this;
    }

    /**
       * Adds an AND filter to the filter.
       * @param {filter/Filter} filter The filter.
       */
  }, {
    key: "andFilter",
    value: function andFilter(filter) {
      if (this.expression == null || (filter === null || filter === void 0 ? void 0 : filter.expression) == null || (filter === null || filter === void 0 ? void 0 : filter.expression) === undefined) {
        throw new Error('Cannot create a conjunction with an empty expression.');
      }
      var left = this.expression;
      var right = filter.expression;
      this.expression = new _Conjunction["default"](left, right);
      return this;
    }

    /**
       * Adds an OR condition to the filter.
       * @param {String} field The field to compare.
       * @param {filter/Operator} operator The operator to use.
       * @param {String|Number|Boolean} value The value to compare.
       */
  }, {
    key: "or",
    value: function or(field, operator, value) {
      if (this.expression == null) {
        throw new Error('Cannot create a disjunction with an empty expression.');
      }
      var left = this.expression;
      var right = new _Condition["default"](field, operator, value);
      this.expression = new _Disjunction["default"](left, right);
      return this;
    }

    /**
       * Adds an OR expression to the filter.
       * @param {filter/Expression} expression The expression.
       */
  }, {
    key: "orExpression",
    value: function orExpression(expression) {
      if (this.expression == null || expression == null || expression === undefined) {
        throw new Error('Cannot create a disjunction with an empty expression.');
      }
      var left = this.expression;
      var right = expression;
      this.expression = new _Disjunction["default"](left, right);
      return this;
    }

    /**
       * Adds an OR filter to the filter.
       * @param {filter/Filter} filter The filter.
       */
  }, {
    key: "orFilter",
    value: function orFilter(filter) {
      if (this.expression == null || (filter === null || filter === void 0 ? void 0 : filter.expression) == null || (filter === null || filter === void 0 ? void 0 : filter.expression) === undefined) {
        throw new Error('Cannot create a disjunction with an empty expression.');
      }
      var left = this.expression;
      var right = filter.expression;
      this.expression = new _Disjunction["default"](left, right);
      return this;
    }

    /**
       * Builds the query from the Filter.
       * @return {String} The query.
       */
  }, {
    key: "buildQuery",
    value: function buildQuery() {
      if (this.expression == null) {
        return '';
      }
      return this.expression.buildQuery();
    }

    /**
       * Builds the query from the Filter.
       * @return {String} The query.
       */
  }, {
    key: "toString",
    value: function toString() {
      return this.buildQuery();
    }

    /**
       * Builds the url encodedquery from the Filter.
       * @return {String} The url encoded query.
       */
  }, {
    key: "buildUrlEncodedQuery",
    value: function buildUrlEncodedQuery() {
      return encodeURI(this.buildQuery());
    }
  }]);
  return Filter;
}();